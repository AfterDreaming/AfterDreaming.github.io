    <!DOCTYPE html>
    <html>
    <head>
      <style>
      rect.bordered {
        stroke: #E6E6E6;
        stroke-width:2px;   
      }

      text.mono {
        font-size: 9pt;
        font-family: Consolas, courier;
        fill: #aaa;
      }
      .axis path,
      .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
      }



      </style>
      <meta charset="utf-8">
      <title>Data Visulization Dev</title>
      <link rel="stylesheet" href="normalize.css">
      <script src="js/d3.min.js"></script>
    </head>
    <body>
      <div id="heat-map"></div>
      <div id="stack-bar"></div>

      <script type = "text/javascript">


      function range(start, end) {
        var foo = [];
        for (var i = start; i <= end; i += 100) {
          foo.push(i);
        }
        return foo;
      }

      //var location = range(1, 1404);

      function strColor(s) {
        if (s == 'A')
          return 'blue';
        if (s == 'T')
          return 'yellow';
        if (s == 'G')
          return 'green';
        if (s == 'C')
          return 'red';
        return 'black';
      }

      function numLevel(s) {
        if (s == "Mild"||s =="Low" || s =="Minor"||s == "Susceptible")
          return 1;
        if (s == "Moderate"||s =="Medium" ||s == "Major"||s == "Intermediate")
          return 2;
        if (s == "Severe"||s =="High" || s == "Resistant")
          return 3;

        return 100; //sth is wrong
      }

      var dataset = [ 100, 200,300,400, 500,600,700,800,900,1000,1100,1200,1300,1400 ];

      var margin = { top: 100, right: 0, bottom: 100, left: 100 },
      width = 1920 - margin.left - margin.right,
      height = 1200 - margin.top - margin.bottom,
      gridWidth = Math.floor(width / 100),
      gridHeight = gridWidth,
      legendElementWidth = gridHeight*2;


      var y = d3.scale.ordinal()
      .rangeRoundBands([0, height], .3);

      var x = d3.scale.linear()
      .rangeRound([0, width]);

      var color = d3.scale.ordinal()
      .range(["#c7001e", "#f6a580", "#cccccc", "#92c6db", "#086fad"]);

      color.domain(['Symptoms','Mortality','Complications','Drug_Resistance','At_Risk_Vulnerability']);

      var xAxis = d3.svg.axis()
      .scale(x)
      .orient("top");

      var yAxis = d3.svg.axis()
      .scale(y)
      .orient("left")

      var stack_width = (width + margin.left + margin.right)/1,
      stack_height = (height + margin.top + margin.bottom)/1;


      var svg_stack = d3.select("#stack-bar").append("svg")
      .attr("width", stack_width)
      .attr("height", stack_height)
      .attr("id", "d3-plot")
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");



      d3.tsv("data/DiseaseCharacteristics.tsv", function(data) {
        data.forEach(function(d){
          d['Symptoms'] = +numLevel(d['Symptoms']);
          d['Mortality'] = +numLevel(d['Mortality']);
          d['Complications'] = +numLevel(d['Complications']);
          d['Drug_Resistance'] = +numLevel(d['Drug_Resistance']);
          d['At_Risk_Vulnerability'] = +numLevel(d['At_Risk_Vulnerability']);
          d.N = d['Symptoms']+d['Mortality']+d['Complications']+d['Drug_Resistance']
          +d['Drug_Resistance']+d['At_Risk_Vulnerability'];

          var x0 = 0;
          var idx = 0;
          //debugger;
          d.boxes = color.domain().map(function(attrName) {
          //console.log(attrName);
          //debugger; 
          return {
            name: attrName,
            x0: x0, 
            x1: x0 += +d[attrName],
            N: +d.N,
            //n: +d[idx += 1]
          };
        });
        });
        //debugger;
        var min_val = d3.min(data, function(d) {
          // console.log(d.boxes["0"]);
          // debugger;
          //Symptoms
          return d.boxes["0"].x0;
        });

        var max_val = d3.max(data, function(d) {
          //At_Risk_Vulnerability
          return d.boxes["4"].x1;
        });

        x.domain([min_val, max_val]).nice();
        y.domain(data.map(function(d) { 
          return d.Sequence_ID; 
        })
        );

        svg_stack.append("g")
        .attr("class", "x axis")
        .call(xAxis);

        svg_stack.append("g")
        .attr("class", "y axis")
        .call(yAxis);

        var vakken = svg_stack.selectAll(".sequences")
        .data(data)
        .enter()
        .append("g")
        .attr("class", "bar")
        .attr("transform", function(d) { 
          //debugger;
          return "translate(0," + y(d.Sequence_ID) + ")"; 
        }
        );

        var bars = vakken.selectAll("rect")
        .data(function(d) { return d.boxes; })
        .enter()
        .append("g")
        .attr("class", "subbar");

        bars.append("rect")
        .attr("height", y.rangeBand())
        .attr("x", function(d) { return x(d.x0); })
        .attr("width", function(d) { return x(d.x1) - x(d.x0); })
        .style("fill", function(d) { return color(d.name); });

        bars.append("text")
        .attr("x", function(d) { return x(d.x0); })
        .attr("y", y.rangeBand()/2)
        .attr("dy", "0.5em")
        .attr("dx", "0.5em")
        .style("font" ,"10px sans-serif")
        .style("text-anchor", "begin")
        .text(function(d) { return d.n !== 0 && (d.x1-d.x0)>3 ? d.n : "" });

        vakken.insert("rect",":first-child")
        .attr("height", y.rangeBand())
        .attr("x", "1")
        .attr("width", width)
        .attr("fill-opacity", "0.5")
        .style("fill", "#F5F5F5")
        .attr("class", function(d,index) { return index%2==0 ? "even" : "uneven"; });

        svg_stack.append("g")
        .attr("class", "y axis")
        .append("line")
        .attr("x1", x(0))
        .attr("x2", x(0))
        .attr("y2", height);

        var startp = svg_stack.append("g")
        .attr("class", "legendbox")
        .attr("id", "mylegendbox");
  // this is not nice, we should calculate the bounding box and use that
        var legend_tabs = [0, 120, 200, 375, 450];
        var legend = startp.selectAll(".legend")
        .data(color.domain().slice())
        .enter().append("g")
        .attr("class", "legend")
        .attr("transform", function(d, i) { 
          return "translate(" + legend_tabs[i] + ",-45)";
          });

        legend.append("rect")
        .attr("x", 0)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", color);

        legend.append("text")
        .attr("x", 22)
        .attr("y", 9)
        .attr("dy", ".35em")
        .style("text-anchor", "begin")
        .style("font" ,"10px sans-serif")
        .text(function(d) { return d; });

        d3.selectAll(".axis path")
        .style("fill", "none")
        .style("stroke", "#000")
        .style("shape-rendering", "crispEdges")

        d3.selectAll(".axis line")
        .style("fill", "none")
        .style("stroke", "#000")
        .style("shape-rendering", "crispEdges")

        var movesize = width/2 - startp.node().getBBox().width/2;
        d3.selectAll(".legendbox").attr("transform", "translate(" + movesize  + ",0)");

    });

    var svg_heat = d3.select("#heat-map")
    .append("svg")
    .attr("width", width + margin.left+ margin.right)
    .attr("height",height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    var location_Labels = svg_heat.selectAll(".locationLabel")
    .data(dataset)
    .enter().append("text")
    .text(function(d) { return d; })
    .style("font-size", gridHeight)
    .attr("x", function(d, i) { return d * gridWidth; })
    .attr("y", 0)
    .style("text-anchor", "middle")
    .attr("transform", "translate(" + gridHeight / 2 + ", -6)");

      //deal with the data
      d3.json("data/strains.json", function(data) {
        //var length = data.length;
        //
        //console.log(dataset);
        //debugger;

        var id_Labels = svg_heat.selectAll(".idLabel")
        .data(data)
        .enter()
        .append("text")
        .text(function (d) { return d.id; })
        .attr("x", 0)
        .attr("y", function (d, i) { return  i* gridHeight; })
        .style("font-size", gridHeight)
        .style("text-anchor", "end")
        .attr("transform", "translate(-6," + gridHeight / 1.5 + ")");
        //debugger;


        for (i = 0; i < data.length; i++) {

          var cards = svg_heat.selectAll(".base")
          .data(data[i].sequences);


          cards.enter().append("line")
          .attr("x1", function (d, j) { 
            //debugger;
            return  j; 
          })
          .attr("y1", function (d, j) {
           return  i * gridHeight; 
         })
          .attr("x2", function (d, j) { 
            //debugger;
            return  j; 
          })
          .attr("y2", function (d, j) {
           return  i * gridHeight + gridHeight; 
         })
          .style("stroke", function (d) { 
            return strColor(d); 
          });

          cards.append("title")
          .text(function(d, j) { return " " + d +" location: " + j; });
        }

      })
    </script>
  </body>
  </html>